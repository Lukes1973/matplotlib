/* Generated by Cython 0.9.6.12 on Sun Jul 20 11:01:12 2008 */

#define PY_SSIZE_T_CLEAN
#include "Python.h"
#include "structmember.h"
#ifndef PY_LONG_LONG
  #define PY_LONG_LONG LONG_LONG
#endif
#if PY_VERSION_HEX < 0x02050000
  typedef int Py_ssize_t;
  #define PY_SSIZE_T_MAX INT_MAX
  #define PY_SSIZE_T_MIN INT_MIN
  #define PyInt_FromSsize_t(z) PyInt_FromLong(z)
  #define PyInt_AsSsize_t(o)   PyInt_AsLong(o)
  #define PyNumber_Index(o)    PyNumber_Int(o)
  #define PyIndex_Check(o)     PyNumber_Check(o)
#endif
#if PY_VERSION_HEX < 0x02040000
  #define METH_COEXIST 0
#endif
#ifndef WIN32
  #define __stdcall
  #define __cdecl
#endif
#ifdef __cplusplus
#define __PYX_EXTERN_C extern "C"
#else
#define __PYX_EXTERN_C extern
#endif
#include <math.h>


#ifdef __GNUC__
#define INLINE __inline__
#elif _WIN32
#define INLINE __inline
#else
#define INLINE 
#endif

typedef struct {PyObject **p; char *s;} __Pyx_InternTabEntry; /*proto*/
typedef struct {PyObject **p; char *s; long n; int is_unicode;} __Pyx_StringTabEntry; /*proto*/



static int __pyx_skip_dispatch = 0;


/* Type Conversion Predeclarations */

#define __Pyx_PyBool_FromLong(b) ((b) ? (Py_INCREF(Py_True), Py_True) : (Py_INCREF(Py_False), Py_False))
static INLINE int __Pyx_PyObject_IsTrue(PyObject* x);
static INLINE PY_LONG_LONG __pyx_PyInt_AsLongLong(PyObject* x);
static INLINE unsigned PY_LONG_LONG __pyx_PyInt_AsUnsignedLongLong(PyObject* x);
static INLINE Py_ssize_t __pyx_PyIndex_AsSsize_t(PyObject* b);

#define __pyx_PyInt_AsLong(x) (PyInt_CheckExact(x) ? PyInt_AS_LONG(x) : PyInt_AsLong(x))
#define __pyx_PyFloat_AsDouble(x) (PyFloat_CheckExact(x) ? PyFloat_AS_DOUBLE(x) : PyFloat_AsDouble(x))

static INLINE unsigned char __pyx_PyInt_unsigned_char(PyObject* x);
static INLINE unsigned short __pyx_PyInt_unsigned_short(PyObject* x);
static INLINE char __pyx_PyInt_char(PyObject* x);
static INLINE short __pyx_PyInt_short(PyObject* x);
static INLINE int __pyx_PyInt_int(PyObject* x);
static INLINE long __pyx_PyInt_long(PyObject* x);
static INLINE signed char __pyx_PyInt_signed_char(PyObject* x);
static INLINE signed short __pyx_PyInt_signed_short(PyObject* x);
static INLINE signed int __pyx_PyInt_signed_int(PyObject* x);
static INLINE signed long __pyx_PyInt_signed_long(PyObject* x);
static INLINE long double __pyx_PyInt_long_double(PyObject* x);
#ifdef __GNUC__
/* Test for GCC > 2.95 */
#if __GNUC__ > 2 ||               (__GNUC__ == 2 && (__GNUC_MINOR__ > 95)) 
#define likely(x)   __builtin_expect(!!(x), 1)
#define unlikely(x) __builtin_expect(!!(x), 0)
#else /* __GNUC__ > 2 ... */
#define likely(x)   (x)
#define unlikely(x) (x)
#endif /* __GNUC__ > 2 ... */
#else /* __GNUC__ */
#define likely(x)   (x)
#define unlikely(x) (x)
#endif /* __GNUC__ */
    
static PyObject *__pyx_m;
static PyObject *__pyx_b;
static PyObject *__pyx_empty_tuple;
static int __pyx_lineno;
static char *__pyx_filename;
static char **__pyx_f;

static char __pyx_mdoc[] = "\nPyrex wrapper for NCAR natgrid library for interpolation\nof irregularly spaced data to a grid.\n\ncopyright (c) 2007 by Jeffrey Whitaker.\n\nPermission to use, copy, modify, and distribute this software and its\ndocumentation for any purpose and without fee is hereby granted,\nprovided that the above copyright notices appear in all copies and that\nboth the copyright notices and this permission notice appear in\nsupporting documentation.\nTHE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\nINCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO\nEVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT OR\nCONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF\nUSE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n";

static PyObject *__Pyx_GetName(PyObject *dict, PyObject *name); /*proto*/

static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb); /*proto*/

static int __Pyx_InternStrings(__Pyx_InternTabEntry *t); /*proto*/

static int __Pyx_InitStrings(__Pyx_StringTabEntry *t); /*proto*/

static void __Pyx_AddTraceback(char *funcname); /*proto*/

/* Declarations from _natgrid */

__PYX_EXTERN_C DL_EXPORT(void) c_nnseti(char *, int); /*proto*/
__PYX_EXTERN_C DL_EXPORT(double) *c_natgridd(int, double *, double *, double *, int, int, double *, double *, int *); /*proto*/
__PYX_EXTERN_C DL_EXPORT(void) c_nnsetr(char *, float); /*proto*/


/* Implementation of _natgrid */

/* "/Users/jwhitaker/python/matplotlib/lib/natgrid/src/_natgrid.pyx":32
 *     char *PyString_AsString(object)
 * 
 * def seti(name, value):             # <<<<<<<<<<<<<< 
 *     cdef char *pnam
 *     cdef int ival
 */

static PyObject *__pyx_pf_8_natgrid_seti(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static PyObject *__pyx_pf_8_natgrid_seti(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_name = 0;
  PyObject *__pyx_v_value = 0;
  char *__pyx_v_pnam;
  int __pyx_v_ival;
  PyObject *__pyx_r;
  char *__pyx_1;
  int __pyx_2;
  static char *__pyx_argnames[] = {"name","value",0};
  if (likely(!__pyx_kwds) && likely(PyTuple_GET_SIZE(__pyx_args) == 2)) {
    __pyx_v_name = PyTuple_GET_ITEM(__pyx_args, 0);
    __pyx_v_value = PyTuple_GET_ITEM(__pyx_args, 1);
  }
  else {
    if (unlikely(!PyArg_ParseTupleAndKeywords(__pyx_args, __pyx_kwds, "OO", __pyx_argnames, &__pyx_v_name, &__pyx_v_value))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 32; goto __pyx_L2;}
  }
  goto __pyx_L3;
  __pyx_L2:;
  return NULL;
  __pyx_L3:;
  Py_INCREF(__pyx_v_name);
  Py_INCREF(__pyx_v_value);

  /* "/Users/jwhitaker/python/matplotlib/lib/natgrid/src/_natgrid.pyx":35
 *     cdef char *pnam
 *     cdef int ival
 *     pnam = name; ival = value             # <<<<<<<<<<<<<< 
 *     c_nnseti(pnam, ival)
 * 
 */
  __pyx_1 = PyString_AsString(__pyx_v_name); if (unlikely((!__pyx_1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 35; goto __pyx_L1;}
  __pyx_v_pnam = __pyx_1;
  __pyx_2 = __pyx_PyInt_int(__pyx_v_value); if (unlikely((__pyx_2 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 35; goto __pyx_L1;}
  __pyx_v_ival = __pyx_2;

  /* "/Users/jwhitaker/python/matplotlib/lib/natgrid/src/_natgrid.pyx":36
 *     cdef int ival
 *     pnam = name; ival = value
 *     c_nnseti(pnam, ival)             # <<<<<<<<<<<<<< 
 * 
 * def setr(name, value):
 */
  c_nnseti(__pyx_v_pnam, __pyx_v_ival);

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  __Pyx_AddTraceback("_natgrid.seti");
  __pyx_r = NULL;
  __pyx_L0:;
  Py_DECREF(__pyx_v_name);
  Py_DECREF(__pyx_v_value);
  return __pyx_r;
}

/* "/Users/jwhitaker/python/matplotlib/lib/natgrid/src/_natgrid.pyx":38
 *     c_nnseti(pnam, ival)
 * 
 * def setr(name, value):             # <<<<<<<<<<<<<< 
 *     cdef char *pnam
 *     cdef float fval
 */

static PyObject *__pyx_pf_8_natgrid_setr(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static PyObject *__pyx_pf_8_natgrid_setr(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_name = 0;
  PyObject *__pyx_v_value = 0;
  char *__pyx_v_pnam;
  float __pyx_v_fval;
  PyObject *__pyx_r;
  char *__pyx_1;
  float __pyx_2;
  static char *__pyx_argnames[] = {"name","value",0};
  if (likely(!__pyx_kwds) && likely(PyTuple_GET_SIZE(__pyx_args) == 2)) {
    __pyx_v_name = PyTuple_GET_ITEM(__pyx_args, 0);
    __pyx_v_value = PyTuple_GET_ITEM(__pyx_args, 1);
  }
  else {
    if (unlikely(!PyArg_ParseTupleAndKeywords(__pyx_args, __pyx_kwds, "OO", __pyx_argnames, &__pyx_v_name, &__pyx_v_value))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 38; goto __pyx_L2;}
  }
  goto __pyx_L3;
  __pyx_L2:;
  return NULL;
  __pyx_L3:;
  Py_INCREF(__pyx_v_name);
  Py_INCREF(__pyx_v_value);

  /* "/Users/jwhitaker/python/matplotlib/lib/natgrid/src/_natgrid.pyx":41
 *     cdef char *pnam
 *     cdef float fval
 *     pnam = name; fval = value             # <<<<<<<<<<<<<< 
 *     c_nnsetr(pnam, fval)
 * 
 */
  __pyx_1 = PyString_AsString(__pyx_v_name); if (unlikely((!__pyx_1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 41; goto __pyx_L1;}
  __pyx_v_pnam = __pyx_1;
  __pyx_2 = __pyx_PyFloat_AsDouble(__pyx_v_value); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 41; goto __pyx_L1;}
  __pyx_v_fval = __pyx_2;

  /* "/Users/jwhitaker/python/matplotlib/lib/natgrid/src/_natgrid.pyx":42
 *     cdef float fval
 *     pnam = name; fval = value
 *     c_nnsetr(pnam, fval)             # <<<<<<<<<<<<<< 
 * 
 * def natgridd(x, y, z, xo, yo, zo):
 */
  c_nnsetr(__pyx_v_pnam, __pyx_v_fval);

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  __Pyx_AddTraceback("_natgrid.setr");
  __pyx_r = NULL;
  __pyx_L0:;
  Py_DECREF(__pyx_v_name);
  Py_DECREF(__pyx_v_value);
  return __pyx_r;
}

/* "/Users/jwhitaker/python/matplotlib/lib/natgrid/src/_natgrid.pyx":44
 *     c_nnsetr(pnam, fval)
 * 
 * def natgridd(x, y, z, xo, yo, zo):             # <<<<<<<<<<<<<< 
 *     cdef int npnts, numxout, numyout, ier
 *     cdef Py_ssize_t buflenx, bufleny, buflenz, buflenxo, buflenyo, buflenzo
 */

static PyObject *__pyx_n_RuntimeError;

static PyObject *__pyx_k_1p;
static PyObject *__pyx_k_2p;
static PyObject *__pyx_k_3p;
static PyObject *__pyx_k_4p;
static PyObject *__pyx_k_5p;
static PyObject *__pyx_k_6p;
static PyObject *__pyx_k_7p;

static PyObject *__pyx_builtin_RuntimeError;

static char __pyx_k_1[] = "error getting buffer for x";
static char __pyx_k_2[] = "error getting buffer for y";
static char __pyx_k_3[] = "error getting buffer for z";
static char __pyx_k_4[] = "error getting buffer for x";
static char __pyx_k_5[] = "error getting buffer for y";
static char __pyx_k_6[] = "error getting buffer for z";
static char __pyx_k_7[] = "error in natgridd - ier =";

static PyObject *__pyx_pf_8_natgrid_natgridd(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static PyObject *__pyx_pf_8_natgrid_natgridd(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_x = 0;
  PyObject *__pyx_v_y = 0;
  PyObject *__pyx_v_z = 0;
  PyObject *__pyx_v_xo = 0;
  PyObject *__pyx_v_yo = 0;
  PyObject *__pyx_v_zo = 0;
  int __pyx_v_npnts;
  int __pyx_v_numxout;
  int __pyx_v_numyout;
  int __pyx_v_ier;
  Py_ssize_t __pyx_v_buflenx;
  Py_ssize_t __pyx_v_bufleny;
  Py_ssize_t __pyx_v_buflenz;
  Py_ssize_t __pyx_v_buflenxo;
  Py_ssize_t __pyx_v_buflenyo;
  Py_ssize_t __pyx_v_buflenzo;
  void *__pyx_v_xp;
  void *__pyx_v_yp;
  void *__pyx_v_zp;
  void *__pyx_v_xop;
  void *__pyx_v_yop;
  void *__pyx_v_zop;
  double *__pyx_v_xd;
  double *__pyx_v_yd;
  double *__pyx_v_zd;
  double *__pyx_v_xod;
  double *__pyx_v_yod;
  double *__pyx_v_zod;
  double *__pyx_v_out;
  PyObject *__pyx_v_i;
  PyObject *__pyx_r;
  Py_ssize_t __pyx_1 = 0;
  int __pyx_2;
  PyObject *__pyx_3 = 0;
  PyObject *__pyx_4 = 0;
  long __pyx_5;
  Py_ssize_t __pyx_6 = 0;
  Py_ssize_t __pyx_7 = 0;
  static char *__pyx_argnames[] = {"x","y","z","xo","yo","zo",0};
  if (likely(!__pyx_kwds) && likely(PyTuple_GET_SIZE(__pyx_args) == 6)) {
    __pyx_v_x = PyTuple_GET_ITEM(__pyx_args, 0);
    __pyx_v_y = PyTuple_GET_ITEM(__pyx_args, 1);
    __pyx_v_z = PyTuple_GET_ITEM(__pyx_args, 2);
    __pyx_v_xo = PyTuple_GET_ITEM(__pyx_args, 3);
    __pyx_v_yo = PyTuple_GET_ITEM(__pyx_args, 4);
    __pyx_v_zo = PyTuple_GET_ITEM(__pyx_args, 5);
  }
  else {
    if (unlikely(!PyArg_ParseTupleAndKeywords(__pyx_args, __pyx_kwds, "OOOOOO", __pyx_argnames, &__pyx_v_x, &__pyx_v_y, &__pyx_v_z, &__pyx_v_xo, &__pyx_v_yo, &__pyx_v_zo))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 44; goto __pyx_L2;}
  }
  goto __pyx_L3;
  __pyx_L2:;
  return NULL;
  __pyx_L3:;
  Py_INCREF(__pyx_v_x);
  Py_INCREF(__pyx_v_y);
  Py_INCREF(__pyx_v_z);
  Py_INCREF(__pyx_v_xo);
  Py_INCREF(__pyx_v_yo);
  Py_INCREF(__pyx_v_zo);
  __pyx_v_i = Py_None; Py_INCREF(Py_None);

  /* "/Users/jwhitaker/python/matplotlib/lib/natgrid/src/_natgrid.pyx":49
 *     cdef void *xp, *yp, *zp, *xop, *yop, *zop
 *     cdef double *xd, *yd, *zd, *xod, *yod, *zod, *out
 *     npnts = len(x)             # <<<<<<<<<<<<<< 
 *     numxout = len(xo)
 *     numyout = len(yo)
 */
  __pyx_1 = PyObject_Length(__pyx_v_x); if (unlikely(__pyx_1 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 49; goto __pyx_L1;}
  __pyx_v_npnts = __pyx_1;

  /* "/Users/jwhitaker/python/matplotlib/lib/natgrid/src/_natgrid.pyx":50
 *     cdef double *xd, *yd, *zd, *xod, *yod, *zod, *out
 *     npnts = len(x)
 *     numxout = len(xo)             # <<<<<<<<<<<<<< 
 *     numyout = len(yo)
 *     if PyObject_AsWriteBuffer(x, &xp, &buflenx) <> 0:
 */
  __pyx_1 = PyObject_Length(__pyx_v_xo); if (unlikely(__pyx_1 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 50; goto __pyx_L1;}
  __pyx_v_numxout = __pyx_1;

  /* "/Users/jwhitaker/python/matplotlib/lib/natgrid/src/_natgrid.pyx":51
 *     npnts = len(x)
 *     numxout = len(xo)
 *     numyout = len(yo)             # <<<<<<<<<<<<<< 
 *     if PyObject_AsWriteBuffer(x, &xp, &buflenx) <> 0:
 *         raise RuntimeError('error getting buffer for x')
 */
  __pyx_1 = PyObject_Length(__pyx_v_yo); if (unlikely(__pyx_1 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 51; goto __pyx_L1;}
  __pyx_v_numyout = __pyx_1;

  /* "/Users/jwhitaker/python/matplotlib/lib/natgrid/src/_natgrid.pyx":52
 *     numxout = len(xo)
 *     numyout = len(yo)
 *     if PyObject_AsWriteBuffer(x, &xp, &buflenx) <> 0:             # <<<<<<<<<<<<<< 
 *         raise RuntimeError('error getting buffer for x')
 *     if PyObject_AsWriteBuffer(y, &yp, &bufleny) <> 0:
 */
  __pyx_2 = (PyObject_AsWriteBuffer(__pyx_v_x, (&__pyx_v_xp), (&__pyx_v_buflenx)) != 0);
  if (__pyx_2) {

    /* "/Users/jwhitaker/python/matplotlib/lib/natgrid/src/_natgrid.pyx":53
 *     numyout = len(yo)
 *     if PyObject_AsWriteBuffer(x, &xp, &buflenx) <> 0:
 *         raise RuntimeError('error getting buffer for x')             # <<<<<<<<<<<<<< 
 *     if PyObject_AsWriteBuffer(y, &yp, &bufleny) <> 0:
 *         raise RuntimeError('error getting buffer for y')
 */
    __pyx_3 = PyTuple_New(1); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 53; goto __pyx_L1;}
    Py_INCREF(__pyx_k_1p);
    PyTuple_SET_ITEM(__pyx_3, 0, __pyx_k_1p);
    __pyx_4 = PyObject_Call(__pyx_builtin_RuntimeError, __pyx_3, NULL); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 53; goto __pyx_L1;}
    Py_DECREF(__pyx_3); __pyx_3 = 0;
    __Pyx_Raise(__pyx_4, 0, 0);
    Py_DECREF(__pyx_4); __pyx_4 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 53; goto __pyx_L1;}
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "/Users/jwhitaker/python/matplotlib/lib/natgrid/src/_natgrid.pyx":54
 *     if PyObject_AsWriteBuffer(x, &xp, &buflenx) <> 0:
 *         raise RuntimeError('error getting buffer for x')
 *     if PyObject_AsWriteBuffer(y, &yp, &bufleny) <> 0:             # <<<<<<<<<<<<<< 
 *         raise RuntimeError('error getting buffer for y')
 *     if PyObject_AsWriteBuffer(z, &zp, &buflenz) <> 0:
 */
  __pyx_2 = (PyObject_AsWriteBuffer(__pyx_v_y, (&__pyx_v_yp), (&__pyx_v_bufleny)) != 0);
  if (__pyx_2) {

    /* "/Users/jwhitaker/python/matplotlib/lib/natgrid/src/_natgrid.pyx":55
 *         raise RuntimeError('error getting buffer for x')
 *     if PyObject_AsWriteBuffer(y, &yp, &bufleny) <> 0:
 *         raise RuntimeError('error getting buffer for y')             # <<<<<<<<<<<<<< 
 *     if PyObject_AsWriteBuffer(z, &zp, &buflenz) <> 0:
 *         raise RuntimeError('error getting buffer for z')
 */
    __pyx_3 = PyTuple_New(1); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 55; goto __pyx_L1;}
    Py_INCREF(__pyx_k_2p);
    PyTuple_SET_ITEM(__pyx_3, 0, __pyx_k_2p);
    __pyx_4 = PyObject_Call(__pyx_builtin_RuntimeError, __pyx_3, NULL); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 55; goto __pyx_L1;}
    Py_DECREF(__pyx_3); __pyx_3 = 0;
    __Pyx_Raise(__pyx_4, 0, 0);
    Py_DECREF(__pyx_4); __pyx_4 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 55; goto __pyx_L1;}
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "/Users/jwhitaker/python/matplotlib/lib/natgrid/src/_natgrid.pyx":56
 *     if PyObject_AsWriteBuffer(y, &yp, &bufleny) <> 0:
 *         raise RuntimeError('error getting buffer for y')
 *     if PyObject_AsWriteBuffer(z, &zp, &buflenz) <> 0:             # <<<<<<<<<<<<<< 
 *         raise RuntimeError('error getting buffer for z')
 *     xd = <double *>xp
 */
  __pyx_2 = (PyObject_AsWriteBuffer(__pyx_v_z, (&__pyx_v_zp), (&__pyx_v_buflenz)) != 0);
  if (__pyx_2) {

    /* "/Users/jwhitaker/python/matplotlib/lib/natgrid/src/_natgrid.pyx":57
 *         raise RuntimeError('error getting buffer for y')
 *     if PyObject_AsWriteBuffer(z, &zp, &buflenz) <> 0:
 *         raise RuntimeError('error getting buffer for z')             # <<<<<<<<<<<<<< 
 *     xd = <double *>xp
 *     yd = <double *>yp
 */
    __pyx_3 = PyTuple_New(1); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 57; goto __pyx_L1;}
    Py_INCREF(__pyx_k_3p);
    PyTuple_SET_ITEM(__pyx_3, 0, __pyx_k_3p);
    __pyx_4 = PyObject_Call(__pyx_builtin_RuntimeError, __pyx_3, NULL); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 57; goto __pyx_L1;}
    Py_DECREF(__pyx_3); __pyx_3 = 0;
    __Pyx_Raise(__pyx_4, 0, 0);
    Py_DECREF(__pyx_4); __pyx_4 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 57; goto __pyx_L1;}
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "/Users/jwhitaker/python/matplotlib/lib/natgrid/src/_natgrid.pyx":58
 *     if PyObject_AsWriteBuffer(z, &zp, &buflenz) <> 0:
 *         raise RuntimeError('error getting buffer for z')
 *     xd = <double *>xp             # <<<<<<<<<<<<<< 
 *     yd = <double *>yp
 *     zd = <double *>zp
 */
  __pyx_v_xd = ((double *)__pyx_v_xp);

  /* "/Users/jwhitaker/python/matplotlib/lib/natgrid/src/_natgrid.pyx":59
 *         raise RuntimeError('error getting buffer for z')
 *     xd = <double *>xp
 *     yd = <double *>yp             # <<<<<<<<<<<<<< 
 *     zd = <double *>zp
 *     if PyObject_AsWriteBuffer(xo, &xop, &buflenxo) <> 0:
 */
  __pyx_v_yd = ((double *)__pyx_v_yp);

  /* "/Users/jwhitaker/python/matplotlib/lib/natgrid/src/_natgrid.pyx":60
 *     xd = <double *>xp
 *     yd = <double *>yp
 *     zd = <double *>zp             # <<<<<<<<<<<<<< 
 *     if PyObject_AsWriteBuffer(xo, &xop, &buflenxo) <> 0:
 *         raise RuntimeError('error getting buffer for x')
 */
  __pyx_v_zd = ((double *)__pyx_v_zp);

  /* "/Users/jwhitaker/python/matplotlib/lib/natgrid/src/_natgrid.pyx":61
 *     yd = <double *>yp
 *     zd = <double *>zp
 *     if PyObject_AsWriteBuffer(xo, &xop, &buflenxo) <> 0:             # <<<<<<<<<<<<<< 
 *         raise RuntimeError('error getting buffer for x')
 *     if PyObject_AsWriteBuffer(yo, &yop, &buflenyo) <> 0:
 */
  __pyx_2 = (PyObject_AsWriteBuffer(__pyx_v_xo, (&__pyx_v_xop), (&__pyx_v_buflenxo)) != 0);
  if (__pyx_2) {

    /* "/Users/jwhitaker/python/matplotlib/lib/natgrid/src/_natgrid.pyx":62
 *     zd = <double *>zp
 *     if PyObject_AsWriteBuffer(xo, &xop, &buflenxo) <> 0:
 *         raise RuntimeError('error getting buffer for x')             # <<<<<<<<<<<<<< 
 *     if PyObject_AsWriteBuffer(yo, &yop, &buflenyo) <> 0:
 *         raise RuntimeError('error getting buffer for y')
 */
    __pyx_3 = PyTuple_New(1); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 62; goto __pyx_L1;}
    Py_INCREF(__pyx_k_4p);
    PyTuple_SET_ITEM(__pyx_3, 0, __pyx_k_4p);
    __pyx_4 = PyObject_Call(__pyx_builtin_RuntimeError, __pyx_3, NULL); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 62; goto __pyx_L1;}
    Py_DECREF(__pyx_3); __pyx_3 = 0;
    __Pyx_Raise(__pyx_4, 0, 0);
    Py_DECREF(__pyx_4); __pyx_4 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 62; goto __pyx_L1;}
    goto __pyx_L7;
  }
  __pyx_L7:;

  /* "/Users/jwhitaker/python/matplotlib/lib/natgrid/src/_natgrid.pyx":63
 *     if PyObject_AsWriteBuffer(xo, &xop, &buflenxo) <> 0:
 *         raise RuntimeError('error getting buffer for x')
 *     if PyObject_AsWriteBuffer(yo, &yop, &buflenyo) <> 0:             # <<<<<<<<<<<<<< 
 *         raise RuntimeError('error getting buffer for y')
 *     if PyObject_AsWriteBuffer(zo, &zop, &buflenzo) <> 0:
 */
  __pyx_2 = (PyObject_AsWriteBuffer(__pyx_v_yo, (&__pyx_v_yop), (&__pyx_v_buflenyo)) != 0);
  if (__pyx_2) {

    /* "/Users/jwhitaker/python/matplotlib/lib/natgrid/src/_natgrid.pyx":64
 *         raise RuntimeError('error getting buffer for x')
 *     if PyObject_AsWriteBuffer(yo, &yop, &buflenyo) <> 0:
 *         raise RuntimeError('error getting buffer for y')             # <<<<<<<<<<<<<< 
 *     if PyObject_AsWriteBuffer(zo, &zop, &buflenzo) <> 0:
 *         raise RuntimeError('error getting buffer for z')
 */
    __pyx_3 = PyTuple_New(1); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 64; goto __pyx_L1;}
    Py_INCREF(__pyx_k_5p);
    PyTuple_SET_ITEM(__pyx_3, 0, __pyx_k_5p);
    __pyx_4 = PyObject_Call(__pyx_builtin_RuntimeError, __pyx_3, NULL); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 64; goto __pyx_L1;}
    Py_DECREF(__pyx_3); __pyx_3 = 0;
    __Pyx_Raise(__pyx_4, 0, 0);
    Py_DECREF(__pyx_4); __pyx_4 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 64; goto __pyx_L1;}
    goto __pyx_L8;
  }
  __pyx_L8:;

  /* "/Users/jwhitaker/python/matplotlib/lib/natgrid/src/_natgrid.pyx":65
 *     if PyObject_AsWriteBuffer(yo, &yop, &buflenyo) <> 0:
 *         raise RuntimeError('error getting buffer for y')
 *     if PyObject_AsWriteBuffer(zo, &zop, &buflenzo) <> 0:             # <<<<<<<<<<<<<< 
 *         raise RuntimeError('error getting buffer for z')
 *     xod = <double *>xop
 */
  __pyx_2 = (PyObject_AsWriteBuffer(__pyx_v_zo, (&__pyx_v_zop), (&__pyx_v_buflenzo)) != 0);
  if (__pyx_2) {

    /* "/Users/jwhitaker/python/matplotlib/lib/natgrid/src/_natgrid.pyx":66
 *         raise RuntimeError('error getting buffer for y')
 *     if PyObject_AsWriteBuffer(zo, &zop, &buflenzo) <> 0:
 *         raise RuntimeError('error getting buffer for z')             # <<<<<<<<<<<<<< 
 *     xod = <double *>xop
 *     yod = <double *>yop
 */
    __pyx_3 = PyTuple_New(1); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 66; goto __pyx_L1;}
    Py_INCREF(__pyx_k_6p);
    PyTuple_SET_ITEM(__pyx_3, 0, __pyx_k_6p);
    __pyx_4 = PyObject_Call(__pyx_builtin_RuntimeError, __pyx_3, NULL); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 66; goto __pyx_L1;}
    Py_DECREF(__pyx_3); __pyx_3 = 0;
    __Pyx_Raise(__pyx_4, 0, 0);
    Py_DECREF(__pyx_4); __pyx_4 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 66; goto __pyx_L1;}
    goto __pyx_L9;
  }
  __pyx_L9:;

  /* "/Users/jwhitaker/python/matplotlib/lib/natgrid/src/_natgrid.pyx":67
 *     if PyObject_AsWriteBuffer(zo, &zop, &buflenzo) <> 0:
 *         raise RuntimeError('error getting buffer for z')
 *     xod = <double *>xop             # <<<<<<<<<<<<<< 
 *     yod = <double *>yop
 *     zod = <double *>zop
 */
  __pyx_v_xod = ((double *)__pyx_v_xop);

  /* "/Users/jwhitaker/python/matplotlib/lib/natgrid/src/_natgrid.pyx":68
 *         raise RuntimeError('error getting buffer for z')
 *     xod = <double *>xop
 *     yod = <double *>yop             # <<<<<<<<<<<<<< 
 *     zod = <double *>zop
 *     # output overwrites zo.
 */
  __pyx_v_yod = ((double *)__pyx_v_yop);

  /* "/Users/jwhitaker/python/matplotlib/lib/natgrid/src/_natgrid.pyx":69
 *     xod = <double *>xop
 *     yod = <double *>yop
 *     zod = <double *>zop             # <<<<<<<<<<<<<< 
 *     # output overwrites zo.
 *     out = c_natgridd(npnts, yd, xd, zd, numyout, numxout, yod, xod, &ier)
 */
  __pyx_v_zod = ((double *)__pyx_v_zop);

  /* "/Users/jwhitaker/python/matplotlib/lib/natgrid/src/_natgrid.pyx":71
 *     zod = <double *>zop
 *     # output overwrites zo.
 *     out = c_natgridd(npnts, yd, xd, zd, numyout, numxout, yod, xod, &ier)             # <<<<<<<<<<<<<< 
 *     for i from 0 <= i < buflenzo/8:
 *         zod[i] = out[i]
 */
  __pyx_v_out = c_natgridd(__pyx_v_npnts, __pyx_v_yd, __pyx_v_xd, __pyx_v_zd, __pyx_v_numyout, __pyx_v_numxout, __pyx_v_yod, __pyx_v_xod, (&__pyx_v_ier));

  /* "/Users/jwhitaker/python/matplotlib/lib/natgrid/src/_natgrid.pyx":72
 *     # output overwrites zo.
 *     out = c_natgridd(npnts, yd, xd, zd, numyout, numxout, yod, xod, &ier)
 *     for i from 0 <= i < buflenzo/8:             # <<<<<<<<<<<<<< 
 *         zod[i] = out[i]
 *     if ier != 0:
 */
  __pyx_1 = (__pyx_v_buflenzo / 8);
  for (__pyx_5 = 0; __pyx_5 < __pyx_1; __pyx_5++) {
    __pyx_3 = PyInt_FromLong(__pyx_5); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 72; goto __pyx_L1;}
    Py_DECREF(__pyx_v_i);
    __pyx_v_i = __pyx_3;
    __pyx_3 = 0;

    /* "/Users/jwhitaker/python/matplotlib/lib/natgrid/src/_natgrid.pyx":73
 *     out = c_natgridd(npnts, yd, xd, zd, numyout, numxout, yod, xod, &ier)
 *     for i from 0 <= i < buflenzo/8:
 *         zod[i] = out[i]             # <<<<<<<<<<<<<< 
 *     if ier != 0:
 *        raise RuntimeError('error in natgridd - ier ='%ier)
 */
    __pyx_6 = __pyx_PyIndex_AsSsize_t(__pyx_v_i); if (unlikely((__pyx_6 == (Py_ssize_t)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 73; goto __pyx_L1;}
    __pyx_7 = __pyx_PyIndex_AsSsize_t(__pyx_v_i); if (unlikely((__pyx_7 == (Py_ssize_t)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 73; goto __pyx_L1;}
    (__pyx_v_zod[__pyx_7]) = (__pyx_v_out[__pyx_6]);
  }

  /* "/Users/jwhitaker/python/matplotlib/lib/natgrid/src/_natgrid.pyx":74
 *     for i from 0 <= i < buflenzo/8:
 *         zod[i] = out[i]
 *     if ier != 0:             # <<<<<<<<<<<<<< 
 *        raise RuntimeError('error in natgridd - ier ='%ier)
 */
  __pyx_2 = (__pyx_v_ier != 0);
  if (__pyx_2) {

    /* "/Users/jwhitaker/python/matplotlib/lib/natgrid/src/_natgrid.pyx":75
 *         zod[i] = out[i]
 *     if ier != 0:
 *        raise RuntimeError('error in natgridd - ier ='%ier)             # <<<<<<<<<<<<<< 
 */
    __pyx_4 = PyInt_FromLong(__pyx_v_ier); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 75; goto __pyx_L1;}
    __pyx_3 = PyNumber_Remainder(__pyx_k_7p, __pyx_4); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 75; goto __pyx_L1;}
    Py_DECREF(__pyx_4); __pyx_4 = 0;
    __pyx_4 = PyTuple_New(1); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 75; goto __pyx_L1;}
    PyTuple_SET_ITEM(__pyx_4, 0, __pyx_3);
    __pyx_3 = 0;
    __pyx_3 = PyObject_Call(__pyx_builtin_RuntimeError, __pyx_4, NULL); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 75; goto __pyx_L1;}
    Py_DECREF(__pyx_4); __pyx_4 = 0;
    __Pyx_Raise(__pyx_3, 0, 0);
    Py_DECREF(__pyx_3); __pyx_3 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 75; goto __pyx_L1;}
    goto __pyx_L12;
  }
  __pyx_L12:;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_3);
  Py_XDECREF(__pyx_4);
  __Pyx_AddTraceback("_natgrid.natgridd");
  __pyx_r = NULL;
  __pyx_L0:;
  Py_DECREF(__pyx_v_i);
  Py_DECREF(__pyx_v_x);
  Py_DECREF(__pyx_v_y);
  Py_DECREF(__pyx_v_z);
  Py_DECREF(__pyx_v_xo);
  Py_DECREF(__pyx_v_yo);
  Py_DECREF(__pyx_v_zo);
  return __pyx_r;
}

static __Pyx_InternTabEntry __pyx_intern_tab[] = {
  {&__pyx_n_RuntimeError, "RuntimeError"},
  {0, 0}
};

static __Pyx_StringTabEntry __pyx_string_tab[] = {
  {&__pyx_k_1p, __pyx_k_1, sizeof(__pyx_k_1), 0},
  {&__pyx_k_2p, __pyx_k_2, sizeof(__pyx_k_2), 0},
  {&__pyx_k_3p, __pyx_k_3, sizeof(__pyx_k_3), 0},
  {&__pyx_k_4p, __pyx_k_4, sizeof(__pyx_k_4), 0},
  {&__pyx_k_5p, __pyx_k_5, sizeof(__pyx_k_5), 0},
  {&__pyx_k_6p, __pyx_k_6, sizeof(__pyx_k_6), 0},
  {&__pyx_k_7p, __pyx_k_7, sizeof(__pyx_k_7), 0},
  {0, 0, 0, 0}
};

static struct PyMethodDef __pyx_methods[] = {
  {"seti", (PyCFunction)__pyx_pf_8_natgrid_seti, METH_VARARGS|METH_KEYWORDS, 0},
  {"setr", (PyCFunction)__pyx_pf_8_natgrid_setr, METH_VARARGS|METH_KEYWORDS, 0},
  {"natgridd", (PyCFunction)__pyx_pf_8_natgrid_natgridd, METH_VARARGS|METH_KEYWORDS, 0},
  {0, 0, 0, 0}
};

static void __pyx_init_filenames(void); /*proto*/

PyMODINIT_FUNC init_natgrid(void); /*proto*/
PyMODINIT_FUNC init_natgrid(void) {
  /*--- Libary function declarations ---*/
  __pyx_init_filenames();
  /*--- Module creation code ---*/
  __pyx_m = Py_InitModule4("_natgrid", __pyx_methods, __pyx_mdoc, 0, PYTHON_API_VERSION);
  if (!__pyx_m) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; goto __pyx_L1;};
  __pyx_b = PyImport_AddModule("__builtin__");
  if (!__pyx_b) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; goto __pyx_L1;};
  if (PyObject_SetAttrString(__pyx_m, "__builtins__", __pyx_b) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; goto __pyx_L1;};
  /*--- Intern code ---*/
  if (__Pyx_InternStrings(__pyx_intern_tab) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; goto __pyx_L1;};
  /*--- String init code ---*/
  if (__Pyx_InitStrings(__pyx_string_tab) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; goto __pyx_L1;};
  /*--- Builtin init code ---*/
  __pyx_builtin_RuntimeError = __Pyx_GetName(__pyx_b, __pyx_n_RuntimeError); if (!__pyx_builtin_RuntimeError) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 53; goto __pyx_L1;}
  __pyx_empty_tuple = PyTuple_New(0); if (unlikely(!__pyx_empty_tuple)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; goto __pyx_L1;}
  __pyx_skip_dispatch = 0;
  /*--- Global init code ---*/
  /*--- Function export code ---*/
  /*--- Function import code ---*/
  /*--- Type init code ---*/
  /*--- Type import code ---*/
  /*--- Execution code ---*/

  /* "/Users/jwhitaker/python/matplotlib/lib/natgrid/src/_natgrid.pyx":44
 *     c_nnsetr(pnam, fval)
 * 
 * def natgridd(x, y, z, xo, yo, zo):             # <<<<<<<<<<<<<< 
 *     cdef int npnts, numxout, numyout, ier
 *     cdef Py_ssize_t buflenx, bufleny, buflenz, buflenxo, buflenyo, buflenzo
 */
  return;
  __pyx_L1:;
  __Pyx_AddTraceback("_natgrid");
}

static char *__pyx_filenames[] = {
  "_natgrid.pyx",
};

/* Runtime support code */

static void __pyx_init_filenames(void) {
  __pyx_f = __pyx_filenames;
}

static PyObject *__Pyx_GetName(PyObject *dict, PyObject *name) {
    PyObject *result;
    result = PyObject_GetAttr(dict, name);
    if (!result)
        PyErr_SetObject(PyExc_NameError, name);
    return result;
}

static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb) {
    Py_XINCREF(type);
    Py_XINCREF(value);
    Py_XINCREF(tb);
    /* First, check the traceback argument, replacing None with NULL. */
    if (tb == Py_None) {
        Py_DECREF(tb);
        tb = 0;
    }
    else if (tb != NULL && !PyTraceBack_Check(tb)) {
        PyErr_SetString(PyExc_TypeError,
            "raise: arg 3 must be a traceback or None");
        goto raise_error;
    }
    /* Next, replace a missing value with None */
    if (value == NULL) {
        value = Py_None;
        Py_INCREF(value);
    }
    #if PY_VERSION_HEX < 0x02050000
    if (!PyClass_Check(type))
    #else
    if (!PyType_Check(type))
    #endif
    {
        /* Raising an instance.  The value should be a dummy. */
        if (value != Py_None) {
            PyErr_SetString(PyExc_TypeError,
                "instance exception may not have a separate value");
            goto raise_error;
        }
        /* Normalize to raise <class>, <instance> */
        Py_DECREF(value);
        value = type;
        #if PY_VERSION_HEX < 0x02050000
            if (PyInstance_Check(type)) {
                type = (PyObject*) ((PyInstanceObject*)type)->in_class;
                Py_INCREF(type);
            }
            else {
                PyErr_SetString(PyExc_TypeError,
                    "raise: exception must be an old-style class or instance");
                goto raise_error;
            }
        #else
            type = (PyObject*) type->ob_type;
            Py_INCREF(type);
            if (!PyType_IsSubtype((PyTypeObject *)type, (PyTypeObject *)PyExc_BaseException)) {
                PyErr_SetString(PyExc_TypeError,
                    "raise: exception class must be a subclass of BaseException");
                goto raise_error;
            }
        #endif
    }
    PyErr_Restore(type, value, tb);
    return;
raise_error:
    Py_XDECREF(value);
    Py_XDECREF(type);
    Py_XDECREF(tb);
    return;
}

static int __Pyx_InternStrings(__Pyx_InternTabEntry *t) {
    while (t->p) {
        *t->p = PyString_InternFromString(t->s);
        if (!*t->p)
            return -1;
        ++t;
    }
    return 0;
}

static int __Pyx_InitStrings(__Pyx_StringTabEntry *t) {
    while (t->p) {
        if (t->is_unicode) {
            *t->p = PyUnicode_DecodeUTF8(t->s, t->n - 1, NULL);
        } else {
            *t->p = PyString_FromStringAndSize(t->s, t->n - 1);
        }
        if (!*t->p)
            return -1;
        ++t;
    }
    return 0;
}

#include "compile.h"
#include "frameobject.h"
#include "traceback.h"

static void __Pyx_AddTraceback(char *funcname) {
    PyObject *py_srcfile = 0;
    PyObject *py_funcname = 0;
    PyObject *py_globals = 0;
    PyObject *empty_string = 0;
    PyCodeObject *py_code = 0;
    PyFrameObject *py_frame = 0;
    
    py_srcfile = PyString_FromString(__pyx_filename);
    if (!py_srcfile) goto bad;
    py_funcname = PyString_FromString(funcname);
    if (!py_funcname) goto bad;
    py_globals = PyModule_GetDict(__pyx_m);
    if (!py_globals) goto bad;
    empty_string = PyString_FromString("");
    if (!empty_string) goto bad;
    py_code = PyCode_New(
        0,            /*int argcount,*/
        0,            /*int nlocals,*/
        0,            /*int stacksize,*/
        0,            /*int flags,*/
        empty_string, /*PyObject *code,*/
        __pyx_empty_tuple,  /*PyObject *consts,*/
        __pyx_empty_tuple,  /*PyObject *names,*/
        __pyx_empty_tuple,  /*PyObject *varnames,*/
        __pyx_empty_tuple,  /*PyObject *freevars,*/
        __pyx_empty_tuple,  /*PyObject *cellvars,*/
        py_srcfile,   /*PyObject *filename,*/
        py_funcname,  /*PyObject *name,*/
        __pyx_lineno,   /*int firstlineno,*/
        empty_string  /*PyObject *lnotab*/
    );
    if (!py_code) goto bad;
    py_frame = PyFrame_New(
        PyThreadState_Get(), /*PyThreadState *tstate,*/
        py_code,             /*PyCodeObject *code,*/
        py_globals,          /*PyObject *globals,*/
        0                    /*PyObject *locals*/
    );
    if (!py_frame) goto bad;
    py_frame->f_lineno = __pyx_lineno;
    PyTraceBack_Here(py_frame);
bad:
    Py_XDECREF(py_srcfile);
    Py_XDECREF(py_funcname);
    Py_XDECREF(empty_string);
    Py_XDECREF(py_code);
    Py_XDECREF(py_frame);
}

/* Type Conversion Functions */

static INLINE Py_ssize_t __pyx_PyIndex_AsSsize_t(PyObject* b) {
  Py_ssize_t ival;
  PyObject* x = PyNumber_Index(b);
  if (!x) return -1;
  ival = PyInt_AsSsize_t(x);
  Py_DECREF(x);
  return ival;
}

static INLINE int __Pyx_PyObject_IsTrue(PyObject* x) {
   if (x == Py_True) return 1;
   else if (x == Py_False) return 0;
   else return PyObject_IsTrue(x);
}

static INLINE PY_LONG_LONG __pyx_PyInt_AsLongLong(PyObject* x) {
    if (PyInt_CheckExact(x)) {
        return PyInt_AS_LONG(x);
    }
    else if (PyLong_CheckExact(x)) {
        return PyLong_AsLongLong(x);
    }
    else {
        PY_LONG_LONG val;
        PyObject* tmp = PyNumber_Int(x); if (!tmp) return (PY_LONG_LONG)-1;
        val = __pyx_PyInt_AsLongLong(tmp);
        Py_DECREF(tmp);
        return val;
    }
}

static INLINE unsigned PY_LONG_LONG __pyx_PyInt_AsUnsignedLongLong(PyObject* x) {
    if (PyInt_CheckExact(x)) {
        long val = PyInt_AS_LONG(x);
        if (unlikely(val < 0)) {
            PyErr_SetString(PyExc_TypeError, "Negative assignment to unsigned type.");
            return (unsigned PY_LONG_LONG)-1;
        }
        return val;
    }
    else if (PyLong_CheckExact(x)) {
        return PyLong_AsUnsignedLongLong(x);
    }
    else {
        PY_LONG_LONG val;
        PyObject* tmp = PyNumber_Int(x); if (!tmp) return (PY_LONG_LONG)-1;
        val = __pyx_PyInt_AsUnsignedLongLong(tmp);
        Py_DECREF(tmp);
        return val;
    }
}


static INLINE unsigned char __pyx_PyInt_unsigned_char(PyObject* x) {
    if (sizeof(unsigned char) < sizeof(long)) {
        long long_val = __pyx_PyInt_AsLong(x);
        unsigned char val = (unsigned char)long_val;
        if (unlikely((val != long_val)  || (long_val < 0))) {
            PyErr_SetString(PyExc_OverflowError, "value too large to convert to unsigned char");
            return (unsigned char)-1;
        }
        return val;
    }
    else {
        return __pyx_PyInt_AsLong(x);
    }
}

static INLINE unsigned short __pyx_PyInt_unsigned_short(PyObject* x) {
    if (sizeof(unsigned short) < sizeof(long)) {
        long long_val = __pyx_PyInt_AsLong(x);
        unsigned short val = (unsigned short)long_val;
        if (unlikely((val != long_val)  || (long_val < 0))) {
            PyErr_SetString(PyExc_OverflowError, "value too large to convert to unsigned short");
            return (unsigned short)-1;
        }
        return val;
    }
    else {
        return __pyx_PyInt_AsLong(x);
    }
}

static INLINE char __pyx_PyInt_char(PyObject* x) {
    if (sizeof(char) < sizeof(long)) {
        long long_val = __pyx_PyInt_AsLong(x);
        char val = (char)long_val;
        if (unlikely((val != long_val) )) {
            PyErr_SetString(PyExc_OverflowError, "value too large to convert to char");
            return (char)-1;
        }
        return val;
    }
    else {
        return __pyx_PyInt_AsLong(x);
    }
}

static INLINE short __pyx_PyInt_short(PyObject* x) {
    if (sizeof(short) < sizeof(long)) {
        long long_val = __pyx_PyInt_AsLong(x);
        short val = (short)long_val;
        if (unlikely((val != long_val) )) {
            PyErr_SetString(PyExc_OverflowError, "value too large to convert to short");
            return (short)-1;
        }
        return val;
    }
    else {
        return __pyx_PyInt_AsLong(x);
    }
}

static INLINE int __pyx_PyInt_int(PyObject* x) {
    if (sizeof(int) < sizeof(long)) {
        long long_val = __pyx_PyInt_AsLong(x);
        int val = (int)long_val;
        if (unlikely((val != long_val) )) {
            PyErr_SetString(PyExc_OverflowError, "value too large to convert to int");
            return (int)-1;
        }
        return val;
    }
    else {
        return __pyx_PyInt_AsLong(x);
    }
}

static INLINE long __pyx_PyInt_long(PyObject* x) {
    if (sizeof(long) < sizeof(long)) {
        long long_val = __pyx_PyInt_AsLong(x);
        long val = (long)long_val;
        if (unlikely((val != long_val) )) {
            PyErr_SetString(PyExc_OverflowError, "value too large to convert to long");
            return (long)-1;
        }
        return val;
    }
    else {
        return __pyx_PyInt_AsLong(x);
    }
}

static INLINE signed char __pyx_PyInt_signed_char(PyObject* x) {
    if (sizeof(signed char) < sizeof(long)) {
        long long_val = __pyx_PyInt_AsLong(x);
        signed char val = (signed char)long_val;
        if (unlikely((val != long_val) )) {
            PyErr_SetString(PyExc_OverflowError, "value too large to convert to signed char");
            return (signed char)-1;
        }
        return val;
    }
    else {
        return __pyx_PyInt_AsLong(x);
    }
}

static INLINE signed short __pyx_PyInt_signed_short(PyObject* x) {
    if (sizeof(signed short) < sizeof(long)) {
        long long_val = __pyx_PyInt_AsLong(x);
        signed short val = (signed short)long_val;
        if (unlikely((val != long_val) )) {
            PyErr_SetString(PyExc_OverflowError, "value too large to convert to signed short");
            return (signed short)-1;
        }
        return val;
    }
    else {
        return __pyx_PyInt_AsLong(x);
    }
}

static INLINE signed int __pyx_PyInt_signed_int(PyObject* x) {
    if (sizeof(signed int) < sizeof(long)) {
        long long_val = __pyx_PyInt_AsLong(x);
        signed int val = (signed int)long_val;
        if (unlikely((val != long_val) )) {
            PyErr_SetString(PyExc_OverflowError, "value too large to convert to signed int");
            return (signed int)-1;
        }
        return val;
    }
    else {
        return __pyx_PyInt_AsLong(x);
    }
}

static INLINE signed long __pyx_PyInt_signed_long(PyObject* x) {
    if (sizeof(signed long) < sizeof(long)) {
        long long_val = __pyx_PyInt_AsLong(x);
        signed long val = (signed long)long_val;
        if (unlikely((val != long_val) )) {
            PyErr_SetString(PyExc_OverflowError, "value too large to convert to signed long");
            return (signed long)-1;
        }
        return val;
    }
    else {
        return __pyx_PyInt_AsLong(x);
    }
}

static INLINE long double __pyx_PyInt_long_double(PyObject* x) {
    if (sizeof(long double) < sizeof(long)) {
        long long_val = __pyx_PyInt_AsLong(x);
        long double val = (long double)long_val;
        if (unlikely((val != long_val) )) {
            PyErr_SetString(PyExc_OverflowError, "value too large to convert to long double");
            return (long double)-1;
        }
        return val;
    }
    else {
        return __pyx_PyInt_AsLong(x);
    }
}
